{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"PyToC","text":""},{"location":"#introducao","title":"Introdu\u00e7\u00e3o","text":"<p>Bem-vindo ao reposit\u00f3rio da disciplina de Compiladores.</p> <p>Nesta mat\u00e9ria, exploraremos os fundamentos e os mecanismos envolvidos na constru\u00e7\u00e3o de compiladores \u2014 programas que traduzem c\u00f3digo-fonte de uma linguagem de programa\u00e7\u00e3o para outra, geralmente para linguagem de m\u00e1quina. O objetivo principal \u00e9 compreender como linguagens de programa\u00e7\u00e3o s\u00e3o interpretadas e executadas por computadores, al\u00e9m de desenvolver um compilador de <code>Python</code> para <code>C</code> como projeto pr\u00e1tico, esse compilador ser\u00e1 desenvolvido utilizando o Bison e Flex.</p>"},{"location":"#estrutura-do-repositorio","title":"Estrutura do Reposit\u00f3rio","text":""},{"location":"#descricao-dos-diretorios","title":"Descri\u00e7\u00e3o dos Diret\u00f3rios","text":"<ul> <li><code>Compilador/</code>: Cont\u00e9m os arquivos principais do compilador, incluindo os arquivos Flex e Bison, al\u00e9m do execut\u00e1vel gerado.</li> <li><code>Estudo/</code>: Diret\u00f3rio com materiais de estudo e resumos das semanas iniciais.</li> <li><code>docs/</code>: Diret\u00f3rio com documenta\u00e7\u00e3o detalhada, incluindo atas, planejamento e atividades semanais.</li> <li><code>semana 1/</code>, <code>semana2/</code>, <code>semana3/</code>: Diret\u00f3rios organizados por semana.</li> <li><code>mkdocs.yml</code>: Arquivo de configura\u00e7\u00e3o para gerar documenta\u00e7\u00e3o com o MkDocs.</li> </ul> <p>Essa estrutura foi projetada para organizar o projeto de forma clara, separando o c\u00f3digo-fonte, documenta\u00e7\u00e3o, materiais de estudo e vers\u00f5es semanais do compilador.</p>"},{"location":"#como-executar","title":"Como Executar","text":"<ol> <li> <p>Clonar o reposit\u00f3rio <code>bash    git clone https://github.com/Tiago1604/compiladores_14    cd compiladores_14</code></p> </li> <li> <p>Instalar depend\u00eancias</p> </li> <li>\u00c9 necess\u00e1rio ter Flex e Bison instalados no sistema.  </li> <li>Em distribui\u00e7\u00f5es Linux baseadas em Debian/Ubuntu:      <code>sudo apt-get update</code> <code>sudo apt-get install flex bison</code></li> <li> <p>Em outras plataformas, consulte a documenta\u00e7\u00e3o.</p> </li> <li> <p>Entre em Compilador</p> <ul> <li>Para compilar manualmente: <code>bison -d parser.y</code> <code>flex scanner.l</code> <code>gcc -o compilador parser.tab.c lex.yy.c -lfl</code></li> </ul> <p><code>./compilador</code> ou <code>./compilador &lt; entrada.txt</code></p> </li> </ol>"},{"location":"#atividades-semanais","title":"Atividades Semanais","text":"<p>A cada semana, novas atividades e exerc\u00edcios ser\u00e3o postados neste reposit\u00f3rio, acompanhados de explica\u00e7\u00f5es e instru\u00e7\u00f5es para sua realiza\u00e7\u00e3o.</p>"},{"location":"#membros-da-equipe","title":"Membros da Equipe","text":"Filipe Tiago Isabelle da Costa Jo\u00e3o Pedro Jo\u00e3o Pedro"},{"location":"atas/ata1/","title":"Ata da Reuni\u00e3o - Sprint 1","text":"<p>Data: 26/03/2025 Hora Prevista: 14:00 - 16:00 Hora Realizada: 14:00 - 16:00 Local: Presencial  </p>"},{"location":"atas/ata1/#participantes","title":"Participantes","text":"<ul> <li>Jo\u00e3o Pedro Costa</li> <li>Tiago Albuquerque</li> <li>Isabelle Costa</li> <li>Filipe Bressanelli </li> <li>Jo\u00e3o Pedro Ferreira</li> </ul>"},{"location":"atas/ata1/#pauta-da-reuniao","title":"Pauta da Reuni\u00e3o","text":"<ol> <li>Pr\u00e1tica de implementa\u00e7\u00e3o inicial.</li> <li>Defini\u00e7\u00e3o da metodologia de trabalho.</li> <li>Alinhamento de hor\u00e1rios para reuni\u00f5es semanais.</li> <li>Brainstorm sobre as tecnologias a serem utilizadas no projeto.</li> <li>Estabelecimento do fluxo de trabalho organizado por etapas semanais.</li> </ol>"},{"location":"atas/ata1/#decisoes-tomadas","title":"Decis\u00f5es Tomadas","text":"<ul> <li>Metodologia: Ser\u00e1 utilizada uma abordagem incremental, com entregas semanais baseadas em sprints.</li> <li>Ferramentas: Decidiu-se pelo uso de Flex e Bison para a constru\u00e7\u00e3o do compilador.</li> </ul>"},{"location":"atas/ata1/#proximos-passos","title":"Pr\u00f3ximos Passos","text":"<ol> <li>Configurar o ambiente de desenvolvimento com Flex e Bison.</li> <li>Criar a estrutura inicial do reposit\u00f3rio.</li> <li>Implementar o analisador l\u00e9xico b\u00e1sico.</li> <li>Preparar exemplos simples de c\u00f3digo Python para teste.</li> </ol>"},{"location":"atas/ata2/","title":"Ata da Reuni\u00e3o - Sprint 2","text":"<p>Data: 09/04/2025 Hora Prevista: 14:00 - 16:00 Hora Realizada: 14:00 - 16:00 Local: Presencial  </p>"},{"location":"atas/ata2/#participantes","title":"Participantes","text":"<ul> <li>Jo\u00e3o Pedro Costa</li> <li>Tiago Albuquerque</li> <li>Isabelle Costa</li> <li>Filipe Bressanelli </li> <li>Jo\u00e3o Pedro Ferreira</li> </ul>"},{"location":"atas/ata2/#pauta-da-reuniao","title":"Pauta da Reuni\u00e3o","text":"<ol> <li>Revis\u00e3o do progresso da Sprint 1.</li> <li>Discuss\u00e3o sobre o analisador l\u00e9xico implementado.</li> <li>Planejamento da implementa\u00e7\u00e3o do analisador sint\u00e1tico.</li> <li>Organiza\u00e7\u00e3o do fluxo de commits no reposit\u00f3rio.</li> </ol>"},{"location":"atas/ata2/#decisoes-tomadas","title":"Decis\u00f5es Tomadas","text":"<ul> <li>Analisador L\u00e9xico: O analisador l\u00e9xico b\u00e1sico foi conclu\u00eddo e validado com exemplos simples.</li> <li>Analisador Sint\u00e1tico: Ser\u00e1 iniciado o desenvolvimento do analisador sint\u00e1tico utilizando Bison.</li> <li>Fluxo de Trabalho: Adotar a estrat\u00e9gia de branches no Git para organizar o desenvolvimento (ex.: <code>main</code>, <code>dev</code>, <code>feature/analise-sintatica</code>).</li> <li>Revis\u00e3o de C\u00f3digo: Implementar revis\u00f5es de c\u00f3digo regulares para garantir a qualidade do c\u00f3digo.</li> </ul>"},{"location":"atas/ata2/#proximos-passos","title":"Pr\u00f3ximos Passos","text":"<ol> <li>Implementar o analisador sint\u00e1tico b\u00e1sico com suporte a express\u00f5es aritm\u00e9ticas.</li> <li>Testar a integra\u00e7\u00e3o entre o analisador l\u00e9xico e o sint\u00e1tico.</li> <li>Atualizar a documenta\u00e7\u00e3o no diret\u00f3rio <code>docs/</code>.</li> </ol>"},{"location":"atividades_semanais/Semana1/","title":"Semana 1 - Hello World","text":"<p>Na primeira semana, realizamos a instala\u00e7\u00e3o e configura\u00e7\u00e3o do ambiente de desenvolvimento e fizemos a implementa\u00e7\u00e3o b\u00e1sica e testes inicias.</p>"},{"location":"atividades_semanais/Semana1/#s-atividades-realizadas","title":"S Atividades realizadas","text":"<ul> <li>Realizamos a implementa\u00e7\u00e3o de dois principais exemplos, ambos utilizando as ferramentas Flex e Bison;</li> <li>O primeiro se referia \u00e0 implementa\u00e7\u00e3o de um exemplo simples de \"Hello World\";</li> <li>O segundo se referia \u00e0 implementa\u00e7\u00e3o de uma simples calculadora que aceitava uma cadeia de n\u00fameros e s\u00edmbolos.</li> </ul> <p>Os exemplos permitiram enteder o funcionamento e implementa\u00e7\u00e3o inicial de um compilador, entendendo o processo de an\u00e1lise l\u00e9xica e sint\u00e1tica realizada pelas ferramentas utilizadas.</p> <p>Segue o guia para compilar o exemplo \"Hello World\" que est\u00e1 na pasta \"semana 1\":</p>"},{"location":"atividades_semanais/Semana1/#compilando-e-executando-o-exemplo-hellol-helloy","title":"Compilando e executando o exemplo <code>hello.l</code> + <code>hello.y</code>","text":"<p>Para compilar e executar o exemplo, siga os passos abaixo:</p> <ol> <li> <p>Gerar os arquivos do Bison (no terminal, no mesmo diret\u00f3rio):     <code>bash     bison -d hello.y</code></p> <ul> <li>Isso criar\u00e1 o hello.tab.c (com o c\u00f3digo C do parser) e o hello.tab.h (com as defini\u00e7\u00f5es dos tokens).</li> </ul> </li> <li> <p>Gerar o arquivo do Flex:     <code>bash     flex hello.l</code></p> <ul> <li>Isso criar\u00e1 o lex.yy.c (c\u00f3digo C do analisador l\u00e9xico).</li> </ul> </li> <li> <p>Compilar tudo junto (usando o gcc ou outro compilador C):     <code>bash     gcc -o hello hello.tab.c lex.yy.c -lfl</code></p> <ul> <li>A op\u00e7\u00e3o <code>-lfl</code> linka a biblioteca do Flex (em algumas distribui\u00e7\u00f5es, pode ser necess\u00e1rio usar <code>-ll</code>).</li> </ul> </li> <li> <p>Executar o bin\u00e1rio gerado:     <code>bash     ./hello</code></p> <ul> <li>Se voc\u00ea digitar HelloWorld (ou usar um arquivo de entrada contendo <code>Hello World</code>), o parser deve reconhecer e imprimir Hello, World! na tela, conforme as regras de gram\u00e1tica definidas.</li> </ul> </li> </ol>"},{"location":"atividades_semanais/Semana2/","title":"Semana 2 - Analisador","text":"<p>Na segunda semana, avan\u00e7amos no uso das ferramentas Flex e Bison, implementando um analisador mais complexo que reconhece n\u00fameros e processa entradas.</p>"},{"location":"atividades_semanais/Semana2/#atividades-realizadas","title":"Atividades Realizadas","text":"<p>Durante a segunda semana, focamos no desenvolvimento de um analisador l\u00e9xico e sint\u00e1tico mais robusto, utilizando novamente as ferramentas Flex e Bison.</p> <p>As atividades principais realizadas foram:</p> <ul> <li>Implementa\u00e7\u00e3o de um analisador de n\u00fameros: criamos regras no Flex para reconhecer n\u00fameros inteiros (positivos e negativos), usando express\u00f5es regulares.</li> <li>Defini\u00e7\u00e3o de uma gram\u00e1tica simples no Bison: definimos regras para que o parser pudesse interpretar as entradas recebidas, associando-as a a\u00e7\u00f5es espec\u00edficas, como imprimir o n\u00famero lido.</li> <li>Configura\u00e7\u00e3o do fluxo de entrada: testamos tanto a entrada manual no terminal quanto a leitura de dados a partir de um arquivo (<code>entrada.txt</code>), garantindo flexibilidade na forma de uso do programa.</li> <li>Tratamento de entradas inv\u00e1lidas: deixamos o analisador preparado para lidar com caracteres n\u00e3o reconhecidos, com a possibilidade de estender o tratamento de erros caso necess\u00e1rio.</li> </ul> <p>Al\u00e9m da pr\u00e1tica de programa\u00e7\u00e3o, tamb\u00e9m aprofundamos nossos estudos: - Revisamos o funcionamento da comunica\u00e7\u00e3o entre o analisador l\u00e9xico (Flex) e o sint\u00e1tico (Bison). - Entendemos melhor como o Flex gera tokens e como o Bison organiza a l\u00f3gica de parser atrav\u00e9s das produ\u00e7\u00f5es e a\u00e7\u00f5es associadas. - Aprendemos como compilar e linkar corretamente os arquivos gerados, ajustando comandos conforme o ambiente de desenvolvimento.</p> <p>Essas atividades ajudaram a consolidar a base para projetos mais complexos nas pr\u00f3ximas semanas.</p>"},{"location":"atividades_semanais/Semana2/#compilando-e-executando-o-exemplo-exemplol-exemploy","title":"Compilando e executando o exemplo <code>exemplo.l</code> + <code>exemplo.y</code>","text":"<ol> <li> <p>Gerar o arquivo do Bison <code>bash     bison -d exemplo.y</code></p> <ul> <li>Isso criar\u00e1 dois arquivos: <code>exemplo.tab.c</code> e <code>exemplo.tab.h</code> (o <code>-d</code> gera o <code>.h</code> que cont\u00e9m as defini\u00e7\u00f5es dos tokens).</li> </ul> </li> <li> <p>Gerar o arquivo do Flex <code>bash     flex exemplo.l</code></p> <ul> <li>Isso criar\u00e1 um arquivo <code>lex.yy.c</code>.</li> </ul> </li> <li> <p>Compilar tudo junto     Use um compilador C (por exemplo, gcc) para gerar o execut\u00e1vel:     <code>bash     gcc -o parser exemplo.tab.c lex.yy.c -lfl</code></p> <ul> <li>A op\u00e7\u00e3o <code>-lfl</code> linka a biblioteca do Flex. Em algumas distros, pode ser necess\u00e1rio <code>-ll</code> (ou <code>-lfl -ll</code>) dependendo das vers\u00f5es, mas normalmente <code>-lfl</code> \u00e9 suficiente.</li> </ul> </li> <li> <p>Executar o programa </p> <ul> <li>Se quiser digitar manualmente os dados:   <code>bash   ./parser</code>   Em seguida, digite os n\u00fameros na tela e pressione Enter ao final de cada. Para encerrar, pressione <code>Ctrl+D</code> (em sistemas Unix) ou <code>Ctrl+Z</code> (em Windows).</li> <li>Se quiser processar o arquivo <code>entrada.txt</code>:   <code>bash   ./parser entrada.txt</code></li> </ul> </li> <li> <p>Verificar a sa\u00edda </p> <ul> <li>A cada n\u00famero reconhecido, o programa imprime <code>N\u00famero lido: &lt;valor&gt;</code>.</li> <li>O que n\u00e3o bater com <code>[+\\-]?[0-9]{1,10}</code> ser\u00e1 ignorado ou tratado conforme suas regras.  </li> <li>Caso queira tratar caracteres n\u00e3o reconhecidos como erro, basta ajustar a regra <code>.</code> no arquivo <code>.l</code> para gerar alguma mensagem ou retornar um token de erro.</li> </ul> </li> </ol>"},{"location":"atividades_semanais/Semana3/","title":"Semana 3 - Analisador L\u00e9xico Inicial","text":"<p>Na terceira semana, realizamos a implementa\u00e7\u00e3o inicial do analisador l\u00e9xico do compilador. </p> <p>Adicionamos os tokens conforme a linguagem definida, incluindo: - Palavras-chave, - N\u00fameros, - Identificadores, - S\u00edmbolos.</p> <p>Essa etapa foi essencial para identificar e categorizar os elementos b\u00e1sicos do c\u00f3digo-fonte, garantindo que o compilador reconhe\u00e7a corretamente os componentes da linguagem alvo.</p> <p>O trabalho foi baseado no conte\u00fado apresentado durante a aula pr\u00e1tica, com foco na cria\u00e7\u00e3o do arquivo scanner.l.</p>"},{"location":"atividades_semanais/Semana3/#arquivo-inicial-scannerl","title":"Arquivo inicial \"scanner.l\"","text":"<pre><code>%{\n#include &lt;stdio.h&gt;\n%}\n\n/* Defini\u00e7\u00f5es de padr\u00f5es de token e a\u00e7\u00f5es */\n%%\n\nif          { printf(\"KW_IF\\n\"); }\nwhile       { printf(\"KW_WHILE\\n\"); }\n\n\"//\".*     { /* Ignorar coment\u00e1rios de linha */ }\n\n\"/*\"([^*]|\\*+[^*/])*\\*+\\/    { /* Ignorar coment\u00e1rios de bloco */ }\n\n[a-zA-Z_][a-zA-Z0-9_]*  { printf(\"IDENT(%s)\\n\", yytext); }\n\n[0-9]+(\\.[0-9]+)?  { printf(\"NUMBER(%s)\\n\", yytext); }\n\n[+\\-*/=]   { printf(\"OPERATOR(%s)\\n\", yytext); }\n\n[ \\t\\n]+  { /* N\u00e3o faz nada */ }\n\n.  { printf(\"UNKNOWN(%s)\\n\", yytext); }\n\n%%\n\n/* Fun\u00e7\u00e3o auxiliar do Flex (quando termina o arquivo de entrada) */\nint yywrap(void) {\n    return 1;\n}\n\n/* Fun\u00e7\u00e3o principal: executa o analisador l\u00e9xico */\nint main(void) {\n    yylex();\n    return 0;\n}\n</code></pre>"},{"location":"decisoes/decisao/","title":"Decis\u00f5es T\u00e9cnicas","text":"<p>Este documento descreve as principais decis\u00f5es t\u00e9cnicas tomadas durante o desenvolvimento do compilador de Python para C, utilizando Flex e Bison.</p>"},{"location":"decisoes/decisao/#linguagens-e-ferramentas-utilizadas","title":"Linguagens e Ferramentas Utilizadas","text":"<ul> <li>Flex: Ferramenta escolhida para a an\u00e1lise l\u00e9xica, respons\u00e1vel por identificar tokens no c\u00f3digo Python.</li> <li>Bison: Ferramenta utilizada para a an\u00e1lise sint\u00e1tica, respons\u00e1vel por validar a gram\u00e1tica e gerar a \u00e1rvore sint\u00e1tica.</li> <li>MkDocs: Ferramenta para documenta\u00e7\u00e3o do projeto, com o tema Material Design para uma interface moderna e organizada.</li> </ul>"},{"location":"decisoes/decisao/#estrutura-do-projeto","title":"Estrutura do Projeto","text":"<ul> <li>Organiza\u00e7\u00e3o Modular: O projeto foi dividido em diret\u00f3rios espec\u00edficos para c\u00f3digo-fonte, documenta\u00e7\u00e3o, materiais de estudo e vers\u00f5es semanais.</li> <li>Reposit\u00f3rio Git: Utilizado para controle de vers\u00e3o, com branches organizados para cada funcionalidade ou sprint.</li> </ul>"},{"location":"decisoes/decisao/#configuracao-do-ambiente","title":"Configura\u00e7\u00e3o do Ambiente","text":"<ul> <li>Depend\u00eancias:</li> <li>Flex e Bison devem estar instalados no sistema.</li> <li>Em distribui\u00e7\u00f5es Linux baseadas em Debian/Ubuntu:     <code>bash     sudo apt-get install flex bison</code></li> <li>Compila\u00e7\u00e3o:</li> <li>O compilador \u00e9 gerado utilizando o GCC:     <code>bash     gcc -o compilador parser.tab.c lex.yy.c -lfl</code></li> </ul>"},{"location":"decisoes/decisao/#decisoes-de-design","title":"Decis\u00f5es de Design","text":"<ul> <li>Subconjunto de Python: O compilador suporta um subconjunto de Python, incluindo:</li> <li>Estruturas condicionais (<code>if</code>, <code>else</code>).</li> <li>Opera\u00e7\u00f5es aritm\u00e9ticas e l\u00f3gicas.</li> <li>Declara\u00e7\u00f5es de vari\u00e1veis simples.</li> <li>Gera\u00e7\u00e3o de C\u00f3digo C: Durante a an\u00e1lise sint\u00e1tica, o c\u00f3digo Python \u00e9 traduzido diretamente para C, com suporte a estruturas equivalentes.</li> </ul>"},{"location":"decisoes/decisao/#documentacao","title":"Documenta\u00e7\u00e3o","text":"<ul> <li>Estrutura da Documenta\u00e7\u00e3o:</li> <li>Planejamento: Inclui cronograma, metodologia e planejamento das sprints.</li> <li>Atas de Reuni\u00e3o: Registro das decis\u00f5es tomadas em cada sprint.</li> <li>Atividades Semanais: Relat\u00f3rios de progresso semanais.</li> <li>Ponto de Controle: Relat\u00f3rios de marcos importantes no projeto.</li> <li>Tema do MkDocs:</li> <li>Tema Material Design com suporte a modo claro e escuro.</li> <li>\u00cdcones personalizados para navega\u00e7\u00e3o.</li> </ul>"},{"location":"decisoes/decisao/#fluxo-de-trabalho","title":"Fluxo de Trabalho","text":"<ul> <li>Branches no Git:</li> <li><code>main</code>: Branch principal com as vers\u00f5es est\u00e1veis.</li> <li><code>feat/&lt;nome&gt;</code>: Branches espec\u00edficas para cada funcionalidade ou tarefa.</li> <li>Commits:</li> <li>Mensagens de commit seguem o padr\u00e3o: <code>[Tipo]: Descri\u00e7\u00e3o breve</code>.</li> </ul>"},{"location":"decisoes/decisao/#justificativas","title":"Justificativas","text":"<ul> <li>Flex e Bison: Escolhidos por serem ferramentas amplamente utilizadas para constru\u00e7\u00e3o de compiladores, com boa integra\u00e7\u00e3o e suporte \u00e0 linguagem C.</li> <li>MkDocs: Escolhido para documenta\u00e7\u00e3o devido \u00e0 sua simplicidade e suporte a temas modernos.</li> </ul> <p>Essas decis\u00f5es t\u00e9cnicas foram tomadas para garantir que o projeto seja modular, eficiente e bem documentado, atendendo aos requisitos da disciplina e do compilador.</p>"},{"location":"planejamento/cronograma/","title":"Cronograma do Projeto de Compiladores","text":"Sprint Per\u00edodo Objetivos Principais Principais Entregas Tarefas Respons\u00e1veis Revisores Sprint 1 24/03 a 09/04 - Formar equipes, configurar ambiente e definir linguagem-fonte. - Documento inicial da linguagem. 1. Definir escopo do compilador. Todos Todos - Elaborar a gram\u00e1tica inicial. - Prot\u00f3tipo de gram\u00e1tica no Bison. 2. Configurar reposit\u00f3rio e ferramentas. Isabelle, Jo\u00e3o Pedro (johnaopedro) Filipe, Jo\u00e3o Pedro (JoaoPedro2206) - Ambiente configurado e testado. 3. Criar gram\u00e1tica inicial no Flex/Bison. Jo\u00e3o Pedro (johnaopedro), Tiago Isabelle, Filipe Sprint 2 10/04 a 30/04 - Concluir an\u00e1lise l\u00e9xica e iniciar an\u00e1lise sint\u00e1tica. - Analisador l\u00e9xico funcional. 1. Finalizar express\u00f5es regulares no Flex. Filipe, Jo\u00e3o Pedro (johnaopedro) Tiago, Isabelle - Preparar material para o P1. - Primeiras regras sint\u00e1ticas no Bison. 2. Iniciar parser no Bison. Tiago, Isabelle Filipe, Jo\u00e3o Pedro (johnaopedro) - Apresenta\u00e7\u00e3o do P1. 3. Preparar slides e formul\u00e1rio do P1. Jo\u00e3o Pedro (JoaoPedro2206), Filipe Tiago, Isabelle Sprint 3 01/05 a 14/05 - Evoluir o parser e iniciar an\u00e1lise sem\u00e2ntica. - Parser mais completo. 1. Estender regras gramaticais no Bison. Isabelle, Tiago Jo\u00e3o Pedro (JoaoPedro2206), Filipe - Implementar AST e tabela de s\u00edmbolos. - Estruturas de dados iniciais (AST e tabela de s\u00edmbolos). 2. Criar AST e tabela de s\u00edmbolos. Jo\u00e3o Pedro (JoaoPedro2206), Filipe Isabelle, Jo\u00e3o Pedro (johnaopedro) - Analisador sem\u00e2ntico b\u00e1sico. 3. Implementar verifica\u00e7\u00e3o de tipos e escopos. Jo\u00e3o Pedro (johnaopedro), Tiago Filipe, Isabelle Sprint 4 15/05 a 04/06 - Concluir an\u00e1lise sem\u00e2ntica. - Analisador sem\u00e2ntico robusto. 1. Refinar an\u00e1lise sem\u00e2ntica. Filipe, Isabelle Jo\u00e3o Pedro (JoaoPedro2206), Tiago - Implementar gera\u00e7\u00e3o de c\u00f3digo intermedi\u00e1rio. - M\u00f3dulo de c\u00f3digo intermedi\u00e1rio. 2. Criar gerador de c\u00f3digo intermedi\u00e1rio. Jo\u00e3o Pedro (johnaopedro), Tiago Filipe, Jo\u00e3o Pedro (JoaoPedro2206) - Apresenta\u00e7\u00e3o do P2. 3. Preparar apresenta\u00e7\u00e3o do P2. Jo\u00e3o Pedro (JoaoPedro2206), Isabelle Filipe, Tiago Sprint 5 05/06 a 25/06 - Implementar otimiza\u00e7\u00f5es e gera\u00e7\u00e3o de c\u00f3digo final. - M\u00f3dulo de otimiza\u00e7\u00e3o b\u00e1sico. 1. Implementar otimiza\u00e7\u00f5es simples. Tiago, Filipe Isabelle, Jo\u00e3o Pedro (JoaoPedro2206) - Realizar testes integrados. - Gera\u00e7\u00e3o de c\u00f3digo final. 2. Criar tradutor final para linguagem-alvo. Isabelle, Jo\u00e3o Pedro (JoaoPedro2206) Filipe, Jo\u00e3o Pedro (johnaopedro) - Compilador funcional. 3. Testar compilador de ponta a ponta. Jo\u00e3o Pedro (JoaoPedro2206), Tiago Isabelle, Filipe Sprint 6 26/06 a 09/07 - Realizar entrevistas finais. - Apresenta\u00e7\u00e3o do compilador nas entrevistas. 1. Participar das entrevistas finais. Jo\u00e3o Pedro (johnaopedro), Isabelle Filipe, Tiago - Concluir documenta\u00e7\u00e3o e ajustes finais. - Documenta\u00e7\u00e3o completa. 2. Corrigir pend\u00eancias e issues. Filipe, Jo\u00e3o Pedro (johnaopedro) Isabelle, Tiago"},{"location":"planejamento/ferramentas/","title":"Ferramentas Utilizadas","text":""},{"location":"planejamento/ferramentas/#introducao","title":"Introdu\u00e7\u00e3o","text":"<p>Este documento descreve as ferramentas adotadas no desenvolvimento deste trabalho, abrangendo aquelas j\u00e1 implementadas, em uso atual ou previstas para uso futuro. Cada ferramenta desempenha um papel crucial na execu\u00e7\u00e3o e apresenta\u00e7\u00e3o das tarefas realizadas pela equipe.</p> <p>A escolha adequada de ferramentas \u00e9 essencial para o sucesso de projetos de software. Segundo Flores (2022), ferramentas como Microsoft Project, Planner e JIRA s\u00e3o fundamentais para auxiliar gestores na distribui\u00e7\u00e3o, prioriza\u00e7\u00e3o e monitoramento de tarefas, visando \u00e0 efici\u00eancia e efic\u00e1cia do projeto. Al\u00e9m disso, Giocondo et al. (2021) destacam que o uso de ferramentas de gest\u00e3o de projetos, como SCRUM, Kanban, Microsoft Excel, Design Thinking, Azure DevOps e MS Project, contribui significativamente para a organiza\u00e7\u00e3o e acompanhamento das etapas do desenvolvimento de software.</p> <p>As ferramentas est\u00e3o apresentadas na Tabela 1, acompanhadas de seus logotipos e descri\u00e7\u00f5es.</p> <p>Tabela 1: Ferramentas Utilizadas</p> Logo Descri\u00e7\u00e3o Google Docs: Uma ferramenta poderosa para cria\u00e7\u00e3o, edi\u00e7\u00e3o e colabora\u00e7\u00e3o em documentos em tempo real. Ideal para elabora\u00e7\u00e3o de relat\u00f3rios, propostas e outros documentos relacionados ao projeto, com suporte para trabalho em equipe e acesso de qualquer lugar. Google Chrome: O navegador da web mais popular, utilizado para testar a funcionalidade dos sites, navegar por ferramentas e acessar recursos do projeto de forma r\u00e1pida e eficiente. Conhecido pela sua velocidade, seguran\u00e7a e compatibilidade com diversas tecnologias. Git: Sistema de controle de vers\u00e3o essencial para gerenciar altera\u00e7\u00f5es no c\u00f3digo-fonte, permitindo a colabora\u00e7\u00e3o entre os membros da equipe. Com Git, \u00e9 poss\u00edvel manter um hist\u00f3rico completo de modifica\u00e7\u00f5es e resolver conflitos de c\u00f3digo de forma organizada e eficiente. GitHub: Plataforma de hospedagem de c\u00f3digo-fonte que permite a colabora\u00e7\u00e3o em projetos de desenvolvimento de software. Oferece ferramentas para controle de vers\u00f5es, integra\u00e7\u00e3o cont\u00ednua e uma interface para visualiza\u00e7\u00e3o e revis\u00e3o de c\u00f3digo, facilitando a colabora\u00e7\u00e3o em equipe. Microsoft Teams: Plataforma de comunica\u00e7\u00e3o e colabora\u00e7\u00e3o em equipe, que integra chat, videoconfer\u00eancias, compartilhamento de arquivos e outras ferramentas. Ideal para reuni\u00f5es virtuais, gerenciamento de tarefas e discuss\u00e3o de ideias em tempo real. Telegram: Aplicativo de mensagens instant\u00e2neas usado como principal canal de comunica\u00e7\u00e3o da equipe. Permite troca r\u00e1pida de mensagens, envio de arquivos e cria\u00e7\u00e3o de grupos de discuss\u00e3o, ideal para manter todos atualizados e facilitar a intera\u00e7\u00e3o cont\u00ednua entre os membros. Visual Studio Code: Editor de c\u00f3digo-fonte altamente configur\u00e1vel e leve, utilizado para desenvolvimento de software. Suporta v\u00e1rias linguagens de programa\u00e7\u00e3o e oferece extens\u00f5es que facilitam a integra\u00e7\u00e3o com outras ferramentas e plataformas, como o GitHub, sendo essencial para o desenvolvimento do projeto. <p>Fonte: Jo\u00e3o Pedro Costa, 2025</p>"},{"location":"planejamento/ferramentas/#referencias","title":"Refer\u00eancias","text":"<p>FLORES, Lucas da Silva. Ferramentas de Gest\u00e3o de Projetos de Desenvolvimento de Software: um mapeamento sistem\u00e1tico da literatura. 2022. Dispon\u00edvel em: https://lume.ufrgs.br/handle/10183/245266. Acesso em: 11 abr. 2025.</p> <p>GIOCODO, Francisco Ign\u00e1cio Giocondo; MARTINS JUNIOR, Ant\u00f4nio Sergio; MAKIYA, Ieda Kanashiro. Ferramentas de Gest\u00e3o de Projetos para o Desenvolvimento de Softwares: Uma Pesquisa Survey. 2021. Dispon\u00edvel em: https://recima21.com.br/index.php/recima21/article/view/5064. Acesso em: 11 abr. 2025.</p>"},{"location":"planejamento/metodologia/","title":"Metodologia","text":"<p>Neste documento, apresentamos a metodologia adotada para o desenvolvimento do projeto, que combina pr\u00e1ticas do Scrum, do pareamento, da gest\u00e3o de issues no GitHub e do uso de branches para controle de qualidade dos c\u00f3digos. Essa abordagem visa promover a colabora\u00e7\u00e3o, a efici\u00eancia e a entrega cont\u00ednua de valor.</p>"},{"location":"planejamento/metodologia/#scrum","title":"Scrum","text":"<p>O Scrum \u00e9 uma metodologia \u00e1gil que organiza o trabalho em ciclos chamados sprints. Cada sprint possui uma dura\u00e7\u00e3o fixa, durante a qual a equipe trabalha em um conjunto de tarefas priorizadas. As principais cerim\u00f4nias do Scrum, como planejamento, reuni\u00f5es di\u00e1rias (daily stand-ups), revis\u00f5es e retrospectivas, s\u00e3o utilizadas para garantir a transpar\u00eancia, a adapta\u00e7\u00e3o e a melhoria cont\u00ednua.</p>"},{"location":"planejamento/metodologia/#pareamento","title":"Pareamento","text":"<p>O pareamento, ou programa\u00e7\u00e3o em pares, \u00e9 uma pr\u00e1tica em que dois desenvolvedores trabalham juntos em uma \u00fanica esta\u00e7\u00e3o de trabalho. Enquanto um escreve o c\u00f3digo (driver), o outro revisa e fornece feedback em tempo real (observer). Essa t\u00e9cnica melhora a qualidade do c\u00f3digo, facilita a troca de conhecimento e reduz a incid\u00eancia de erros.</p>"},{"location":"planejamento/metodologia/#gestao-de-issues-no-github","title":"Gest\u00e3o de Issues no GitHub","text":"<p>A gest\u00e3o de issues no GitHub \u00e9 utilizada para organizar e rastrear o progresso das tarefas do projeto. Cada issue representa uma unidade de trabalho, que pode ser priorizada, atribu\u00edda a membros da equipe e vinculada a pull requests. Essa pr\u00e1tica garante maior visibilidade do andamento do projeto e facilita a colabora\u00e7\u00e3o entre os integrantes.</p>"},{"location":"planejamento/metodologia/#uso-de-branches-para-controle-de-qualidade","title":"Uso de Branches para Controle de Qualidade","text":"<p>O uso de branches no controle de qualidade dos c\u00f3digos permite que o desenvolvimento seja realizado de forma isolada, sem impactar a base principal do projeto. Cada funcionalidade ou corre\u00e7\u00e3o \u00e9 desenvolvida em uma branch separada, que \u00e9 revisada e testada antes de ser integrada \u00e0 branch principal. Essa pr\u00e1tica reduz o risco de introdu\u00e7\u00e3o de erros e mant\u00e9m a estabilidade do c\u00f3digo.</p> <p>Ao combinar essas quatro abordagens, buscamos criar um ambiente de trabalho colaborativo e \u00e1gil, que favore\u00e7a a entrega de solu\u00e7\u00f5es de alta qualidade.</p>"},{"location":"planejamento/planejamento_das_sprints/","title":"Planejamento das Sprints","text":"<p>Este documento apresenta o planejamento detalhado das sprints para o desenvolvimento de um compilador como parte da disciplina de Compiladores. O objetivo \u00e9 organizar as atividades, definir entregas e acompanhar o progresso do projeto ao longo do semestre. Cada sprint possui objetivos claros, entregas espec\u00edficas e tarefas distribu\u00eddas para garantir o cumprimento dos prazos e a qualidade do trabalho.</p> <p>O planejamento est\u00e1 dividido em seis sprints, cobrindo desde a forma\u00e7\u00e3o das equipes e configura\u00e7\u00e3o do ambiente at\u00e9 a entrega final do compilador e sua documenta\u00e7\u00e3o. A seguir, s\u00e3o descritas as metas e atividades de cada sprint.</p>"},{"location":"planejamento/planejamento_das_sprints/#sprint-1-2403-a-0904","title":"Sprint 1 (24/03 a 09/04)","text":"<ul> <li> <p>Objetivos Principais </p> <ul> <li>[x] Formar as equipes e organizar o ambiente de trabalho (configurar reposit\u00f3rios, ferramentas, Flex, Bison etc.).  </li> <li>[x] Definir a linguagem-fonte do compilador (sintaxe e sem\u00e2ntica b\u00e1sica).  </li> <li>[x] Elaborar a primeira vers\u00e3o da gram\u00e1tica formal (livre de contexto).  </li> </ul> </li> <li> <p>Principais Entregas </p> <ul> <li>[x] Documento inicial descrevendo a linguagem (tokens, estruturas, exemplos de c\u00f3digo).  </li> <li>[x] Prot\u00f3tipo de gram\u00e1tica reconhecida pelo Bison (ainda n\u00e3o funcional, mas j\u00e1 planejada).  </li> <li>[x] Ambiente configurado e testado (cada membro deve conseguir compilar e rodar um \u201chello world\u201d do Flex/Bison).  </li> </ul> </li> <li> <p>Tarefas e Atividades </p> <ol> <li>[x] Definir o escopo do compilador.  </li> <li>[x] Configurar reposit\u00f3rio e adicionar todos os membros.  </li> <li>[x] Configurar ferramentas: Flex, Bison, compilador C/C++.  </li> <li>[x] Criar gram\u00e1tica inicial no Bison e arquivo de regras l\u00e9xicas no Flex.  </li> <li>[x] Revisar e atualizar a documenta\u00e7\u00e3o do projeto.  </li> </ol> </li> </ul>"},{"location":"planejamento/planejamento_das_sprints/#sprint-2-1004-a-3004","title":"Sprint 2 (10/04 a 30/04)","text":"<ul> <li> <p>Objetivos Principais </p> <ul> <li>[x] Concluir a an\u00e1lise l\u00e9xica (Flex) e iniciar a an\u00e1lise sint\u00e1tica (Bison).  </li> <li>[x] Implementar identifica\u00e7\u00e3o de tokens e testar o reconhecimento b\u00e1sico da linguagem.  </li> <li>[x] Preparar o material para o Ponto de Controle P1.  </li> </ul> </li> <li> <p>Principais Entregas </p> <ul> <li>[x] Analisador l\u00e9xico funcional (arquivo .l completo).  </li> <li>[x] Primeiras regras sint\u00e1ticas implementadas no arquivo .y.  </li> <li>[x] Formul\u00e1rio de apresenta\u00e7\u00e3o do P1 preenchido at\u00e9 28/04.  </li> <li>[ ] Apresenta\u00e7\u00e3o no dia 30/04.  </li> </ul> </li> <li> <p>Tarefas e Atividades </p> <ol> <li>[x] Finalizar as express\u00f5es regulares no Flex.  </li> <li>[x] Iniciar o parser no Bison.  </li> <li>[x] Testar analisador l\u00e9xico e parser inicial.  </li> <li>[ ] Preparar slides/demonstrativo para o P1.  </li> <li>[x] Preencher o formul\u00e1rio do P1.  </li> </ol> </li> </ul>"},{"location":"planejamento/planejamento_das_sprints/#sprint-3-0105-a-1405","title":"Sprint 3 (01/05 a 14/05)","text":"<ul> <li> <p>Objetivos Principais </p> <ul> <li>[ ] Evoluir o analisador sint\u00e1tico com novas produ\u00e7\u00f5es gramaticais.  </li> <li>[ ] Iniciar a estrutura interna do compilador (\u00e1rvore sint\u00e1tica, tabela de s\u00edmbolos).  </li> <li>[ ] Dar os primeiros passos na an\u00e1lise sem\u00e2ntica.  </li> </ul> </li> <li> <p>Principais Entregas </p> <ul> <li>[ ] Parser com cobertura mais ampla da gram\u00e1tica.  </li> <li>[ ] Estrutura de dados (AST e tabela de s\u00edmbolos) definidas e parcialmente implementadas.  </li> <li>[ ] Analisador sem\u00e2ntico inicial identificando erros b\u00e1sicos.  </li> </ul> </li> <li> <p>Tarefas e Atividades </p> <ol> <li>[ ] Estender as regras gramaticais no Bison.  </li> <li>[ ] Criar e popular a tabela de s\u00edmbolos.  </li> <li>[ ] Construir a AST.  </li> <li>[ ] Implementar verifica\u00e7\u00e3o de tipos e escopo simples.  </li> </ol> </li> </ul>"},{"location":"planejamento/planejamento_das_sprints/#sprint-4-1505-a-0406","title":"Sprint 4 (15/05 a 04/06)","text":"<ul> <li> <p>Objetivos Principais </p> <ul> <li>[ ] Concluir an\u00e1lise sem\u00e2ntica principal.  </li> <li>[ ] Implementar a gera\u00e7\u00e3o de c\u00f3digo intermedi\u00e1rio.  </li> <li>[ ] Preparar o ponto de controle P2.  </li> </ul> </li> <li> <p>Principais Entregas </p> <ul> <li>[ ] Analisador sem\u00e2ntico robusto.  </li> <li>[ ] M\u00f3dulo de gera\u00e7\u00e3o de c\u00f3digo intermedi\u00e1rio.  </li> <li>[ ] Formul\u00e1rio do P2 preenchido at\u00e9 02/06.  </li> <li>[ ] Apresenta\u00e7\u00e3o do ponto de controle P2 em 04/06.  </li> </ul> </li> <li> <p>Tarefas e Atividades </p> <ol> <li>[ ] Refinar a an\u00e1lise sem\u00e2ntica.  </li> <li>[ ] Criar gerador de c\u00f3digo intermedi\u00e1rio.  </li> <li>[ ] Configurar testes para instru\u00e7\u00f5es intermedi\u00e1rias.  </li> <li>[ ] Preparar apresenta\u00e7\u00e3o P2.  </li> </ol> </li> </ul>"},{"location":"planejamento/planejamento_das_sprints/#sprint-5-0506-a-2506","title":"Sprint 5 (05/06 a 25/06)","text":"<ul> <li> <p>Objetivos Principais </p> <ul> <li>[ ] Introduzir e testar otimiza\u00e7\u00f5es no c\u00f3digo intermedi\u00e1rio.  </li> <li>[ ] Implementar a gera\u00e7\u00e3o de c\u00f3digo final.  </li> <li>[ ] Realizar testes integrados e corre\u00e7\u00f5es de bugs.  </li> <li>[ ] Entregar o compilador final at\u00e9 27/06.  </li> </ul> </li> <li> <p>Principais Entregas </p> <ul> <li>[ ] M\u00f3dulo de otimiza\u00e7\u00e3o b\u00e1sico.  </li> <li>[ ] M\u00f3dulo de gera\u00e7\u00e3o de c\u00f3digo final.  </li> <li>[ ] Compilador \u201crodando de ponta a ponta\u201d.  </li> </ul> </li> <li> <p>Tarefas e Atividades </p> <ol> <li>[ ] Projetar e implementar otimiza\u00e7\u00f5es simples.  </li> <li>[ ] Criar tradutor final.  </li> <li>[ ] Testar em m\u00faltiplos programas de exemplo.  </li> <li>[ ] Entregar o compilador at\u00e9 27/06.  </li> </ol> </li> </ul>"},{"location":"planejamento/planejamento_das_sprints/#sprint-6-2606-a-0907","title":"Sprint 6 (26/06 a 09/07)","text":"<ul> <li> <p>Objetivos Principais </p> <ul> <li>[ ] Realizar as entrevistas finais.  </li> <li>[ ] Ajustar eventuais pend\u00eancias do compilador.  </li> <li>[ ] Concluir a documenta\u00e7\u00e3o e finalizar a disciplina.  </li> </ul> </li> <li> <p>Principais Entregas </p> <ul> <li>[ ] Apresenta\u00e7\u00e3o do compilador nas entrevistas.  </li> <li>[ ] Corre\u00e7\u00f5es finais e documenta\u00e7\u00e3o completa.  </li> </ul> </li> <li> <p>Tarefas e Atividades </p> <ol> <li>[ ] Entrevistas de entrega.  </li> <li>[ ] Corrigir issues identificadas.  </li> <li>[ ] Documentar o projeto.  </li> </ol> </li> </ul>"},{"location":"ponto_de_controle/ponto_de_controle1/","title":"Ponto de Controle 1","text":""},{"location":"ponto_de_controle/ponto_de_controle1/#definicao-do-projeto","title":"Defini\u00e7\u00e3o do Projeto","text":"<p>O objetivo do projeto \u00e9 desenvolver um compilador que traduz um subconjunto da linguagem Python para C. O compilador deve realizar an\u00e1lise l\u00e9xica e sint\u00e1tica, reconhecendo estruturas b\u00e1sicas da linguagem Python, como declara\u00e7\u00f5es de vari\u00e1veis, atribui\u00e7\u00f5es, express\u00f5es aritm\u00e9ticas, comandos condicionais, e comandos de impress\u00e3o. O resultado esperado \u00e9 um c\u00f3digo C equivalente ao c\u00f3digo Python de entrada.</p>"},{"location":"ponto_de_controle/ponto_de_controle1/#linguagem-de-programacao-escolhida","title":"Linguagem de Programa\u00e7\u00e3o Escolhida","text":"<p>A linguagem escolhida para o desenvolvimento do compilador \u00e9 C, utilizando as ferramentas Flex e Bison. A escolha se justifica pela efici\u00eancia dessas ferramentas na constru\u00e7\u00e3o de analisadores l\u00e9xicos e sint\u00e1ticos, al\u00e9m de sua ampla utiliza\u00e7\u00e3o em projetos de compiladores. A tradu\u00e7\u00e3o para C foi escolhida devido \u00e0 sua simplicidade e proximidade com o hardware, permitindo a gera\u00e7\u00e3o de c\u00f3digo eficiente.</p>"},{"location":"ponto_de_controle/ponto_de_controle1/#planejamento-das-sprints","title":"Planejamento das Sprints","text":"<ul> <li>Sprint 1: Defini\u00e7\u00e3o do projeto e configura\u00e7\u00e3o de ambiente.</li> <li>Sprint 2: Capacita\u00e7\u00e3o Individual em Bison e Analisador L\u00e9xico.</li> <li>Sprint 3: Implementa\u00e7\u00e3o do analisador l\u00e9xico (scanner) para reconhecer tokens b\u00e1sicos da linguagem Python, como palavras-chave, identificadores, operadores e delimitadores.</li> <li>Sprint 4: Implementa\u00e7\u00e3o do analisador sint\u00e1tico (parser) com suporte a regras gramaticais b\u00e1sicas da linguagem Python.</li> <li>Sprint 5: Integra\u00e7\u00e3o do scanner e parser, com gera\u00e7\u00e3o de c\u00f3digo C equivalente ao c\u00f3digo Python de entrada.</li> <li>Sprint 6: Testes e valida\u00e7\u00e3o do compilador, incluindo casos de uso mais complexos e ajustes finais.</li> </ul>"},{"location":"ponto_de_controle/ponto_de_controle1/#o-que-foi-implementado","title":"O que Foi Implementado","text":"<ul> <li>Analisador L\u00e9xico (scanner.l):</li> <li>Reconhecimento de palavras-chave da linguagem Python, como <code>print</code>, <code>if</code>, <code>else</code>, <code>int</code>, entre outras.</li> <li>Identifica\u00e7\u00e3o de operadores e delimitadores.</li> <li>Suporte a n\u00fameros inteiros e identificadores.</li> <li> <p>Ignora espa\u00e7os em branco e caracteres n\u00e3o reconhecidos com mensagens de aviso.</p> </li> <li> <p>Analisador Sint\u00e1tico (parser.y):</p> </li> <li>Implementa\u00e7\u00e3o de regras gramaticais para:<ul> <li>Declara\u00e7\u00f5es de vari\u00e1veis.</li> <li>Atribui\u00e7\u00f5es.</li> <li>Express\u00f5es aritm\u00e9ticas.</li> <li>Comandos condicionais.</li> <li>Comandos de impress\u00e3o.</li> </ul> </li> <li>Suporte a opera\u00e7\u00f5es aritm\u00e9ticas b\u00e1sicas e compara\u00e7\u00f5es.</li> <li>Gera\u00e7\u00e3o de mensagens de sa\u00edda que representam o c\u00f3digo C equivalente ao c\u00f3digo Python de entrada.</li> </ul>"},{"location":"problemas_e_solucoes/problemas_e_solucoes1/","title":"Problemas Encontrados e Solu\u00e7\u00f5es Adotadas","text":"<p>Este documento descreve os principais problemas enfrentados durante o desenvolvimento do compilador de Python para C e as solu\u00e7\u00f5es adotadas para resolv\u00ea-los.</p>"},{"location":"problemas_e_solucoes/problemas_e_solucoes1/#problemas-e-solucoes","title":"Problemas e Solu\u00e7\u00f5es","text":""},{"location":"problemas_e_solucoes/problemas_e_solucoes1/#1-dificuldade-na-integracao-entre-flex-e-bison","title":"1. Dificuldade na Integra\u00e7\u00e3o entre Flex e Bison","text":"<ul> <li>Problema: Inicialmente, houve dificuldades para integrar o analisador l\u00e9xico (Flex) com o analisador sint\u00e1tico (Bison), especialmente na defini\u00e7\u00e3o e uso dos tokens.</li> <li>Solu\u00e7\u00e3o: Foi realizada uma revis\u00e3o detalhada da documenta\u00e7\u00e3o de Flex e Bison. Al\u00e9m disso, utilizamos o arquivo de cabe\u00e7alho gerado pelo Bison (<code>parser.tab.h</code>) para garantir que os tokens definidos no Flex fossem reconhecidos corretamente pelo Bison.</li> </ul>"},{"location":"problemas_e_solucoes/problemas_e_solucoes1/#2-dificuldade-na-integracao-entre-flex-e-bison-no-mac","title":"2. Dificuldade na Integra\u00e7\u00e3o entre Flex e Bison no MAC","text":"<ul> <li>Problema: Inicialmente, houve dificuldades para integrar o analisador l\u00e9xico (Flex) com o analisador sint\u00e1tico (Bison), especialmente no sistema operacional macOS.</li> <li>Solu\u00e7\u00e3o: Foi realizada uma revis\u00e3o detalhada da documenta\u00e7\u00e3o de Flex e Bison. Al\u00e9m disso, utilizamos o arquivo de cabe\u00e7alho gerado pelo Bison para garantir o funcionamento.</li> </ul>"},{"location":"problemas_e_solucoes/problemas_e_solucoes1/#3-erro-ao-gerar-o-codigo-com-gcc","title":"3. Erro ao Gerar o C\u00f3digo com GCC","text":"<ul> <li>Problema: Durante a compila\u00e7\u00e3o do projeto com GCC, surgiram erros relacionados a fun\u00e7\u00f5es n\u00e3o definidas ou conflitos de tipos.</li> <li>Solu\u00e7\u00e3o: Verificamos as depend\u00eancias e inclu\u00edmos a biblioteca <code>-lfl</code> no comando de compila\u00e7\u00e3o para resolver os erros relacionados ao Flex. O comando final ficou assim:   ```bash   gcc -o compilador parser.tab.c lex.yy.c -lfl</li> </ul>"},{"location":"problemas_e_solucoes/problemas_e_solucoes1/#4-organizacao-do-repositorio","title":"4. Organiza\u00e7\u00e3o do Reposit\u00f3rio","text":"<ul> <li>Problema: A estrutura inicial do reposit\u00f3rio estava desorganizada, dificultando a localiza\u00e7\u00e3o de arquivos e o controle de vers\u00f5es.</li> <li>Solu\u00e7\u00e3o: Reestruturamos o reposit\u00f3rio, separando os arquivos em diret\u00f3rios espec\u00edficos, como Compilador/, docs/, e Estudo/. Tamb\u00e9m adotamos o uso de branches no Git para organizar o fluxo de trabalho.</li> </ul>"},{"location":"problemas_e_solucoes/problemas_e_solucoes1/#5-configurar-os-condicionais-no-lexico-e-bison","title":"5. Configurar os Condicionais no L\u00e9xico e Bison","text":"<ul> <li>Problema: Houve dificuldades para implementar condicionais no analisador l\u00e9xico e no analisador sint\u00e1tico, especialmente na defini\u00e7\u00e3o de regras que dependem de estados espec\u00edficos.</li> <li>Solu\u00e7\u00e3o: Foram utilizados ferramentas para aux\u00edlio.</li> </ul>"}]}